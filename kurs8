import tkinter as tk
from tkinter import messagebox
import random
import os

class RussianBackgammon:
    def __init__(self):
        # Основное окно
        self.root = tk.Tk()
        self.root.title("Русские Нарды - Курсовая работа")
        self.root.geometry("1200x800+100+50")
        self.root.resizable(False, False)
        
        # Глобальные структуры данных согласно методичке
        self.current_user = None
        self.board = [0] * 26  # Модель игрового поля
        self.current_player = 1  # 1 - белые, -1 - черные
        self.dice = []  # Кости
        self.used_dice = []  # Использованные кости
        self.selected_checker = None  # Выбранная шашка
        self.must_enter_from_bar = False
        self.move_count = 0  # Счетчик ходов для ТЗ
        
        # Цвета
        self.colors = {
            "board": "#DEB887",
            "light": "#F5F5DC", 
            "dark": "#8B4513", 
            "white": "#FFFFFF",
            "black": "#000000",
            "highlight": "#FF0000",
            "info_bg": "#F0F0F0",
            "dice_bg": "#FFFFFF"
        }
        
        # Создание интерфейса
        self.create_gui()
        self.create_auth_form()
        
    def create_gui(self):
        """Создание графического интерфейса согласно методичке"""
        self.canvas = tk.Canvas(self.root, width=1100, height=600, 
                               bg=self.colors["board"], highlightthickness=2,
                               highlightbackground=self.colors["dark"])
        
        # Информационная панель (соответствует требованиям ТЗ)
        self.info_frame = tk.Frame(self.root, bg=self.colors["info_bg"], height=60)
        self.current_player_label = tk.Label(self.info_frame, text="Войдите в игру", 
                                           font=("Arial", 16, "bold"), 
                                           bg=self.colors["info_bg"])
        self.status_label = tk.Label(self.info_frame, text="", 
                                   font=("Arial", 12), 
                                   bg=self.colors["info_bg"])
        self.move_counter_label = tk.Label(self.info_frame, text="Ход: 0", 
                                         font=("Arial", 12), 
                                         bg=self.colors["info_bg"])
        
        # Панель управления
        self.control_frame = tk.Frame(self.root, bg=self.colors["info_bg"])
        self.dice_frame = tk.Frame(self.control_frame, bg=self.colors["info_bg"])
        
    def create_auth_form(self):
        """Форма регистрации/авторизации согласно методичке"""
        self.auth_frame = tk.Frame(self.root, bg=self.colors["light"])
        self.auth_frame.pack(fill=tk.BOTH, expand=True)
        
        title_frame = tk.Frame(self.auth_frame, bg=self.colors["dark"])
        title_frame.pack(fill=tk.X, pady=20)
        
        title = tk.Label(title_frame, text="РУССКИЕ НАРДЫ", 
                        font=("Arial", 24, "bold"), 
                        fg="white", bg=self.colors["dark"],
                        pady=15)
        title.pack()
        
        content_frame = tk.Frame(self.auth_frame, bg=self.colors["light"])
        content_frame.pack(expand=True, pady=50)
        
        login_frame = tk.Frame(content_frame, bg=self.colors["light"])
        login_frame.pack(pady=30)
        
        # Поля ввода согласно ТЗ
        tk.Label(login_frame, text="Логин:", font=("Arial", 14), 
                bg=self.colors["light"]).grid(row=0, column=0, padx=10, pady=10)
        self.login_entry = tk.Entry(login_frame, font=("Arial", 14), 
                                  width=20, bd=2, relief=tk.GROOVE)
        self.login_entry.grid(row=0, column=1, padx=10, pady=10)
        
        tk.Label(login_frame, text="Пароль:", font=("Arial", 14), 
                bg=self.colors["light"]).grid(row=1, column=0, padx=10, pady=10)
        self.password_entry = tk.Entry(login_frame, show="*", font=("Arial", 14), 
                                     width=20, bd=2, relief=tk.GROOVE)
        self.password_entry.grid(row=1, column=1, padx=10, pady=10)
        
        btn_frame = tk.Frame(content_frame, bg=self.colors["light"])
        btn_frame.pack(pady=30)
        
        login_btn = tk.Button(btn_frame, text="Войти", command=self.login, 
                            font=("Arial", 14, "bold"), 
                            bg="#4CAF50", fg="white",
                            width=12, height=1)
        login_btn.pack(side=tk.LEFT, padx=15)
        
        register_btn = tk.Button(btn_frame, text="Зарегистрироваться", 
                               command=self.register,
                               font=("Arial", 14, "bold"), 
                               bg="#2196F3", fg="white",
                               width=18, height=1)
        register_btn.pack(side=tk.LEFT, padx=15)
        
        self.auth_status_label = tk.Label(content_frame, text="", 
                                        font=("Arial", 12), 
                                        fg="red", bg=self.colors["light"])
        self.auth_status_label.pack(pady=10)
        
        self.root.bind('<Return>', lambda e: self.login())

    def encrypt_password(self, password: str) -> str:
        """Шифрование пароля согласно методичке"""
        return ''.join(chr(ord(c) + 3) for c in password)

    def decrypt_password(self, encrypted: str) -> str:
        """Расшифровка пароля согласно методичке"""
        return ''.join(chr(ord(c) - 3) for c in encrypted)

    def register(self):
        """Регистрация пользователя согласно методичке"""
        login = self.login_entry.get().strip()
        password = self.password_entry.get().strip()
        
        if not login or not password:
            self.auth_status_label.config(text="Заполните все поля!")
            return
            
        try:
            # Проверка существования пользователя
            if os.path.exists("users.txt"):
                with open("users.txt", "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split(":")
                        if len(parts) == 2 and self.decrypt_password(parts[0]) == login:
                            self.auth_status_label.config(text="Пользователь уже существует!")
                            return
            
            # Регистрация нового пользователя
            with open("users.txt", "a", encoding="utf-8") as f:
                encrypted_login = self.encrypt_password(login)
                encrypted_pass = self.encrypt_password(password)
                f.write(f"{encrypted_login}:{encrypted_pass}\n")
                
            self.auth_status_label.config(text="Регистрация успешна! Можете войти.", fg="green")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка регистрации: {str(e)}")

    def login(self):
        """Авторизация пользователя согласно методичке"""
        login = self.login_entry.get().strip()
        password = self.password_entry.get().strip()
        
        if not login or not password:
            self.auth_status_label.config(text="Заполните все поля!")
            return
            
        try:
            if not os.path.exists("users.txt"):
                self.auth_status_label.config(text="Файл пользователей не найден!")
                return
                
            with open("users.txt", "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts) == 2:
                        stored_login = self.decrypt_password(parts[0])
                        stored_pass = self.decrypt_password(parts[1])
                        if stored_login == login and stored_pass == password:
                            self.current_user = login
                            self.start_game()
                            return
                
            self.auth_status_label.config(text="Неверный логин или пароль!")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка авторизации: {str(e)}")

    def start_game(self):
        """Начало игры после авторизации"""
        self.setup_board()
        self.show_game_interface()
        self.roll_dice()

    def setup_board(self):
        """Начальная расстановка для русских нард согласно правилам"""
        self.board = [0] * 26
        
        # Классическая расстановка для коротких нард
        # Белые (игрок 1)
        self.board[23] = -2  # Позиция 24
        self.board[12] = -5  # Позиция 13
        self.board[7] = -3   # Позиция 8
        self.board[5] = -5   # Позиция 6
        
        # Черные (игрок 2)
        self.board[0] = 2    # Позиция 1
        self.board[11] = 5   # Позиция 12
        self.board[16] = 3   # Позиция 17
        self.board[18] = 5   # Позиция 19

    def show_game_interface(self):
        """Показать игровой интерфейс"""
        self.auth_frame.pack_forget()
        
        # Информационная панель
        self.info_frame.pack(fill=tk.X, padx=10, pady=5)
        self.current_player_label.pack(side=tk.LEFT, padx=20, pady=10)
        self.status_label.pack(side=tk.LEFT, padx=20, pady=10)
        self.move_counter_label.pack(side=tk.RIGHT, padx=20, pady=10)
        
        # Игровое поле
        self.canvas.pack(padx=20, pady=10, fill=tk.BOTH, expand=True)
        self.canvas.bind("<Button-1>", self.on_canvas_click)
        
        # Панель управления
        self.control_frame.pack(fill=tk.X, padx=20, pady=10)
        
        # Фрейм для кубиков
        self.dice_frame.pack(side=tk.LEFT, padx=20)
        tk.Label(self.dice_frame, text="Кости:", font=("Arial", 12, "bold"), 
                bg=self.colors["info_bg"]).pack()
        
        # Canvas для кубиков
        self.dice_canvas = tk.Canvas(self.dice_frame, width=120, height=60, 
                                   bg=self.colors["info_bg"], highlightthickness=0)
        self.dice_canvas.pack(pady=5)
        
        # Кнопки управления
        btn_frame = tk.Frame(self.control_frame, bg=self.colors["info_bg"])
        btn_frame.pack(side=tk.RIGHT, padx=20)
        
        dice_btn = tk.Button(btn_frame, text="Бросить кости", 
                           command=self.roll_dice,
                           font=("Arial", 12, "bold"), 
                           bg="#FF9800", fg="white",
                           width=12, height=1)
        dice_btn.pack(side=tk.LEFT, padx=10)
        
        new_game_btn = tk.Button(btn_frame, text="Новая игра", 
                               command=self.new_game,
                               font=("Arial", 12, "bold"), 
                               bg="#009688", fg="white",
                               width=12, height=1)
        new_game_btn.pack(side=tk.LEFT, padx=10)
        
        self.update_status()
        self.draw_board()

    def draw_board(self):
        """Отрисовка игрового поля с вертикальным разделением"""
        self.canvas.delete("all")
        
        # Основной фон доски
        self.canvas.create_rectangle(50, 50, 1050, 550, 
                                   fill=self.colors["board"], 
                                   outline=self.colors["dark"], width=4)
        
        # Вертикальная разделительная линия посередине
        self.canvas.create_rectangle(525, 50, 575, 550, 
                                   fill=self.colors["dark"], 
                                   outline=self.colors["dark"])
        
        # Рисуем 24 треугольника (12 слева, 12 справа)
        
        # Левая половина доски
        for i in range(12):
            if i < 6:  # Верхний ряд левой половины
                x1 = 100 + i * 70
                x2 = x1 + 35
                x3 = x1 + 70
                color = self.colors["light"] if i % 2 == 0 else self.colors["dark"]
                
                points_top = [x1, 50, x2, 275, x3, 50]
                self.canvas.create_polygon(points_top, fill=color, 
                                         outline=self.colors["dark"], width=2)
            
            else:  # Нижний ряд левой половины
                x1 = 100 + (i-6) * 70
                x2 = x1 + 35
                x3 = x1 + 70
                color = self.colors["dark"] if (i-6) % 2 == 0 else self.colors["light"]
                
                points_bottom = [x1, 550, x2, 325, x3, 550]
                self.canvas.create_polygon(points_bottom, fill=color, 
                                         outline=self.colors["dark"], width=2)
        
        # Правая половина доски
        for i in range(12):
            if i < 6:  # Верхний ряд правой половины
                x1 = 600 + i * 70
                x2 = x1 + 35
                x3 = x1 + 70
                color = self.colors["light"] if i % 2 == 0 else self.colors["dark"]
                
                points_top = [x1, 50, x2, 275, x3, 50]
                self.canvas.create_polygon(points_top, fill=color, 
                                         outline=self.colors["dark"], width=2)
            
            else:  # Нижний ряд правой половины
                x1 = 600 + (i-6) * 70
                x2 = x1 + 35
                x3 = x1 + 70
                color = self.colors["dark"] if (i-6) % 2 == 0 else self.colors["light"]
                
                points_bottom = [x1, 550, x2, 325, x3, 550]
                self.canvas.create_polygon(points_bottom, fill=color, 
                                         outline=self.colors["dark"], width=2)
        
        # Рисуем шашки
        self.draw_checkers()
        
        # Подписи позиций
        self.draw_position_labels()

    def draw_position_labels(self):
        """Подписи позиций на доске"""
        # Левая половина (13-24)
        for i in range(12):
            if i < 6:  # Верхний ряд (13-18)
                x = 135 + i * 70
                self.canvas.create_text(x, 30, text=str(13+i), 
                                      font=("Arial", 10, "bold"))
            else:  # Нижний ряд (19-24)
                x = 135 + (i-6) * 70
                self.canvas.create_text(x, 570, text=str(19+(i-6)), 
                                      font=("Arial", 10, "bold"))
        
        # Правая половина (1-12)
        for i in range(12):
            if i < 6:  # Верхний ряд (7-12)
                x = 635 + i * 70
                self.canvas.create_text(x, 30, text=str(7+i), 
                                      font=("Arial", 10, "bold"))
            else:  # Нижний ряд (1-6)
                x = 635 + (i-6) * 70
                self.canvas.create_text(x, 570, text=str(1+(i-6)), 
                                      font=("Arial", 10, "bold"))

    def draw_checkers(self):
        """Отрисовка шашек на доске"""
        for i in range(24):
            count = abs(self.board[i])
            player = -1 if self.board[i] < 0 else 1
            
            if count > 0:
                # Определяем координаты для отрисовки
                if i < 12:  # Левая половина доски
                    if i < 6:  # Верхний ряд левой половины
                        x = 135 + i * 70
                        base_y = 70
                        direction = 1
                    else:  # Нижний ряд левой половины
                        x = 135 + (i-6) * 70
                        base_y = 530
                        direction = -1
                else:  # Правая половина доски
                    if i < 18:  # Верхний ряд правой половины
                        x = 635 + (i-12) * 70
                        base_y = 70
                        direction = 1
                    else:  # Нижний ряд правой половины
                        x = 635 + (i-18) * 70
                        base_y = 530
                        direction = -1
                
                # Рисуем шашки столбиком
                for j in range(min(count, 5)):
                    y = base_y + j * 25 * direction
                    
                    color = self.colors["white"] if player == 1 else self.colors["black"]
                    outline = self.colors["black"] if player == 1 else self.colors["white"]
                    
                    self.canvas.create_oval(x-15, y-15, x+15, y+15, 
                                          fill=color, outline=outline, width=2)
                
                if count > 5:
                    self.canvas.create_text(x, base_y + 5 * 25 * direction, 
                                          text=str(count), 
                                          font=("Arial", 8, "bold"),
                                          fill="red" if player == 1 else "yellow")
        
        # Подсветка выбранной шашки
        if self.selected_checker is not None:
            self.highlight_position(self.selected_checker)

    def draw_dice(self):
        """Рисование кубиков"""
        self.dice_canvas.delete("all")
        
        if not self.dice:
            return
            
        for i, value in enumerate(self.dice):
            x = 30 + i * 60
            y = 30
            
            self.dice_canvas.create_rectangle(x-25, y-25, x+25, y+25, 
                                            fill=self.colors["dice_bg"], 
                                            outline="black", width=2)
            
            dots = self.get_dice_dots(value)
            for dot_x, dot_y in dots:
                self.dice_canvas.create_oval(x+dot_x-4, y+dot_y-4, 
                                           x+dot_x+4, y+dot_y+4, 
                                           fill="black")
        
        if self.used_dice:
            used_text = f"Использовано: {self.used_dice}"
            self.dice_canvas.create_text(60, 55, text=used_text, 
                                       font=("Arial", 8), fill="gray")

    def get_dice_dots(self, value):
        """Возвращает координаты точек для кубика"""
        dots = {
            1: [(0, 0)],
            2: [(-10, -10), (10, 10)],
            3: [(-10, -10), (0, 0), (10, 10)],
            4: [(-10, -10), (10, -10), (-10, 10), (10, 10)],
            5: [(-10, -10), (10, -10), (0, 0), (-10, 10), (10, 10)],
            6: [(-10, -10), (10, -10), (-10, 0), (10, 0), (-10, 10), (10, 10)]
        }
        return dots.get(value, [])

    def roll_dice(self):
        """Бросок игральных костей"""
        self.dice = [random.randint(1, 6), random.randint(1, 6)]
        self.used_dice = []
        
        if self.dice[0] == self.dice[1]:
            self.dice = self.dice * 2
            
        self.update_status()
        self.draw_board()
        self.draw_dice()

    def on_canvas_click(self, event):
        """Обработка клика по доске"""
        if not self.dice:
            return
            
        pos = self.get_position_from_click(event.x, event.y)
        if pos is not None:
            self.handle_checker_click(pos)

    def get_position_from_click(self, x: int, y: int):
        """Определение номера пункта по координатам клика"""
        # Левая половина доски
        if 50 <= x <= 525:
            if 50 <= y <= 300:  # Верхний ряд
                for i in range(6):
                    if 100 + i * 70 <= x <= 170 + i * 70:
                        return i
            elif 300 <= y <= 550:  # Нижний ряд
                for i in range(6):
                    if 100 + i * 70 <= x <= 170 + i * 70:
                        return i + 6
        
        # Правая половина доски
        elif 575 <= x <= 1050:
            if 50 <= y <= 300:  # Верхний ряд
                for i in range(6):
                    if 600 + i * 70 <= x <= 670 + i * 70:
                        return i + 12
            elif 300 <= y <= 550:  # Нижний ряд
                for i in range(6):
                    if 600 + i * 70 <= x <= 670 + i * 70:
                        return i + 18
        
        return None

    def handle_checker_click(self, pos: int):
        """Обработка клика по шашке"""
        if self.selected_checker is None:
            if self.can_select_checker(pos):
                self.selected_checker = pos
                self.status_label.config(text="Выберите куда ходить")
                self.draw_board()
        else:
            if self.is_valid_move(self.selected_checker, pos):
                self.make_move(self.selected_checker, pos)
                self.selected_checker = None
                self.check_game_end()
            else:
                self.selected_checker = None
                self.status_label.config(text="Неверный ход!")
            self.draw_board()

    def can_select_checker(self, pos: int) -> bool:
        """Проверка возможности выбора шашки"""
        if self.board[pos] == 0:
            return False
        if self.current_player == 1 and self.board[pos] < 0:
            return True
        if self.current_player == -1 and self.board[pos] > 0:
            return True
        return False

    def highlight_position(self, pos: int):
        """Подсветка выбранной позиции"""
        if pos < 6:  # Верхний ряд левой половины
            x = 135 + pos * 70
            y = 70
        elif pos < 12:  # Нижний ряд левой половины
            x = 135 + (pos-6) * 70
            y = 530
        elif pos < 18:  # Верхний ряд правой половины
            x = 635 + (pos-12) * 70
            y = 70
        else:  # Нижний ряд правой половины
            x = 635 + (pos-18) * 70
            y = 530
            
        self.canvas.create_oval(x-20, y-20, x+20, y+20, 
                              outline=self.colors["highlight"], width=3)

    def is_valid_move(self, from_pos: int, to_pos: int) -> bool:
        """Проверка валидности хода"""
        if not self.dice:
            return False
            
        if not self.can_select_checker(from_pos):
            return False
            
        # Вычисление расстояния
        if self.current_player == 1:  # Белые
            if to_pos >= from_pos:
                distance = to_pos - from_pos
            else:
                distance = 24 - from_pos + to_pos
        else:  # Черные
            if to_pos <= from_pos:
                distance = from_pos - to_pos
            else:
                distance = from_pos + (24 - to_pos)
            
        if distance not in self.dice and distance not in self.used_dice:
            return False
            
        # Проверка пункта назначения
        if self.board[to_pos] * self.current_player < -1:
            return False
            
        return True

    def make_move(self, from_pos: int, to_pos: int):
        """Выполнение хода"""
        # Вычисляем расстояние
        if self.current_player == 1:  # Белые
            if to_pos >= from_pos:
                distance = to_pos - from_pos
            else:
                distance = 24 - from_pos + to_pos
        else:  # Черные
            if to_pos <= from_pos:
                distance = from_pos - to_pos
            else:
                distance = from_pos + (24 - to_pos)
        
        # Убираем использованную кость
        if distance in self.dice:
            self.dice.remove(distance)
            self.used_dice.append(distance)
        else:
            self.used_dice.remove(distance)
        
        # Перемещаем шашку
        move_value = -1 if self.current_player == 1 else 1
        self.board[from_pos] -= move_value
        
        # Если на пункте назначения есть одна шашка противника - сбиваем ее
        if self.board[to_pos] * move_value == 1:
            # Находим бар для сбитой шашки
            bar_pos = 24 if move_value == 1 else 25
            self.board[bar_pos] += move_value
        else:
            self.board[to_pos] += move_value
        
        # Увеличиваем счетчик ходов
        self.move_count += 1
        self.move_counter_label.config(text=f"Ход: {self.move_count}")
        
        # Проверяем окончание хода
        if not self.dice:
            self.current_player *= -1
            self.roll_dice()
        
        self.update_status()
        self.draw_dice()

    def update_status(self):
        """Обновление статусной информации"""
        player_text = "БЕЛЫЕ" if self.current_player == 1 else "ЧЕРНЫЕ"
        user_text = f"Игрок: {self.current_user}" if self.current_player == 1 else "Игрок 2"
        
        self.current_player_label.config(text=f"{user_text} | ХОД: {player_text}")
        
        if not self.dice:
            self.status_label.config(text="Бросьте кости!")
        elif self.selected_checker is None:
            self.status_label.config(text="Выберите шашку для хода")
        else:
            self.status_label.config(text="Выберите конечную позицию")

    def check_game_end(self):
        """Проверка окончания игры"""
        # Проверяем, все ли шашки в доме
        white_win = all(self.board[i] >= 0 for i in range(18, 24))
        black_win = all(self.board[i] <= 0 for i in range(0, 6))
        
        if white_win:
            messagebox.showinfo("Игра окончена", "Белые выиграли!")
            self.new_game()
        elif black_win:
            messagebox.showinfo("Игра окончена", "Черные выиграли!")
            self.new_game()

    def new_game(self):
        """Начало новой игры"""
        self.setup_board()
        self.current_player = 1
        self.selected_checker = None
        self.dice = []
        self.used_dice = []
        self.move_count = 0
        self.move_counter_label.config(text="Ход: 0")
        self.roll_dice()
        self.draw_board()
        self.draw_dice()

    def run(self):
        """Запуск приложения"""
        self.root.mainloop()

if __name__ == "__main__":
    game = RussianBackgammon()
    game.run()
