# kursovaya1.py -- –î–õ–ò–ù–ù–´–ï –†–£–°–°–ö–ò–ï –ù–ê–†–î–´ (–ë–ï–ó –°–™–ï–î–ê–ù–ò–Ø, –¢–û–õ–¨–ö–û –ù–ê –°–í–û–ò –®–ê–®–ö–ò)
import tkinter as tk
from tkinter import messagebox
import random
import os

# --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã ---
WHITE = "white"
BLACK = "black"
CHECKERS_PER_PLAYER = 15
USERS_FILE = "users.txt"
ENC_SHIFT = 10

CANVAS_W, CANVAS_H = 960, 520
BOARD_MARGIN = 30
POINT_HEIGHT = 220
NUM_POINTS = 24

CHECKER_RADIUS = 14
STACK_SPACING = 4

# --- –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ ---
def encrypt(text, shift=ENC_SHIFT):
    return "".join(chr(ord(c) + shift) for c in text)

def decrypt(text, shift=ENC_SHIFT):
    return "".join(chr(ord(c) - shift) for c in text)

# --- –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ---
class GameState:
    def __init__(self):
        self.points = [{"white": 0, "black": 0} for _ in range(NUM_POINTS + 1)]
        self.points[24]["white"] = CHECKERS_PER_PLAYER
        self.points[12]["black"] = CHECKERS_PER_PLAYER

        self.head = {WHITE: 0, BLACK: 0}
        self.current_player = WHITE
        self.dice = ()
        self.dice_used = []
        self.selected = None
        self.valid_moves = []
        self.head_moved_this_turn = False  # ‚úÖ –≥–æ–ª–æ–≤–∞ 1 —Ä–∞–∑ –∑–∞ –±—Ä–æ—Å–æ–∫

    def head_point(self, player):
        return 24 if player == WHITE else 12

    def direction_for(self, player):
        if player == WHITE:
            return -1  # 24‚Üí1
        else:  # BLACK
            if self.selected and self.selected <= 12:
                return -1  # 12‚Üí1 (–ø–æ –Ω–∏–∑—É)
            else:
                return +1  # 1‚Üí24‚Üí13 (–ø–æ –≤–µ—Ä—Ö—É)

    def roll_dice(self):
        a = random.randint(1, 6)
        b = random.randint(1, 6)
        if a == b:
            self.dice = (a, a, a, a)
            self.dice_used = [False, False, False, False]
        else:
            self.dice = (a, b)
            self.dice_used = [False, False]
        self.selected = None
        self.valid_moves = []
        self.head_moved_this_turn = False  # ‚úÖ —Å–±—Ä–æ—Å

    def all_dice_used(self):
        return len(self.dice_used) > 0 and all(self.dice_used)

    def can_move_from(self, idx):
        return 1 <= idx <= NUM_POINTS and self.points[idx][self.current_player] > 0

    def possible_targets_from(self, start):
        res = []
        if not self.can_move_from(start):
            return res
        
        head_pt = self.head_point(self.current_player)
        # ‚úÖ –ü–†–ê–í–ò–õ–û: —Å –≥–æ–ª–æ–≤—ã —Ç–æ–ª—å–∫–æ 1 —Ä–∞–∑
        if start == head_pt and self.head_moved_this_turn:
            return res
            
        direction = self.direction_for(self.current_player)
        for di, val in enumerate(self.dice):
            if di >= len(self.dice_used) or self.dice_used[di]:
                continue
            target = start + direction * val
            
            # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–Ω—ã—Ö: 1‚Üí24
            if self.current_player == BLACK and target < 1:
                target = 25 + target
            
            if 1 <= target <= NUM_POINTS:
                # ‚úÖ –¢–û–õ–¨–ö–û –ù–ê –°–í–û–ò –®–ê–®–ö–ò (–ù–ï –Ω–∞ —á—É–∂–∏–µ –≤–æ–æ–±—â–µ!)
                if self.points[target][self.current_player] > 0:
                    res.append((di, target))
            elif target >= 25 or target <= 0:
                # –•–æ–¥ –≤ –≥–æ–ª–æ–≤—É (–≤—Å–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ —à–∞—à–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –≥–æ–ª–æ–≤–µ)
                if all(self.points[i][self.current_player] == 0 for i in range(1, NUM_POINTS + 1) if i != head_pt):
                    res.append((di, 0))
        
        return res

    def apply_move(self, start, target, di):
        player = self.current_player
        if not (0 <= di < len(self.dice_used)):
            return False

        head_pt = self.head_point(player)
        
        # ‚úÖ –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å–Ω—è—Ç–∏—è —Å –≥–æ–ª–æ–≤—ã
        if start == head_pt and not self.head_moved_this_turn:
            self.head_moved_this_turn = True

        if target == 0:  # –≤ –≥–æ–ª–æ–≤—É
            if self.points[start][player] <= 0:
                return False
            self.points[start][player] -= 1
            self.head[player] += 1
        elif 1 <= target <= NUM_POINTS:
            if self.points[start][player] <= 0:
                return False
            # ‚úÖ –¢–û–õ–¨–ö–û –ù–ê –°–í–û–ò –®–ê–®–ö–ò
            if self.points[target][player] <= 0:
                return False
            self.points[start][player] -= 1
            self.points[target][player] += 1
        else:
            return False

        self.dice_used[di] = True
        self.selected = None
        self.valid_moves = []
        return True

    def check_win(self):
        if self.head[WHITE] >= CHECKERS_PER_PLAYER:
            return WHITE
        if self.head[BLACK] >= CHECKERS_PER_PLAYER:
            return BLACK
        return None

# --- –ì–ª–∞–≤–Ω–æ–µ –∏–≥—Ä–æ–≤–æ–µ –æ–∫–Ω–æ ---
class NardyApp:
    def __init__(self, root, user):
        self.root = root
        self.user = user
        root.title(f"–†—É—Å—Å–∫–∏–µ –î–õ–ò–ù–ù–´–ï –Ω–∞—Ä–¥—ã ‚Äî {user}")
        self.state = GameState()

        self.canvas = tk.Canvas(root, width=CANVAS_W, height=CANVAS_H, bg="#f5deb3")
        self.canvas.pack(side=tk.LEFT, padx=8, pady=8)

        right = tk.Frame(root)
        right.pack(side=tk.RIGHT, fill=tk.Y, padx=8, pady=8)

        self.info_label = tk.Label(right, text=f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user}", wraplength=200, justify="left")
        self.info_label.pack(pady=6)

        self.turn_label = tk.Label(right, text="–•–æ–¥: –±–µ–ª—ã–µ", font=("Arial", 12, "bold"))
        self.turn_label.pack(pady=4)

        self.dice_label = tk.Label(right, text="–ö–æ—Å—Ç–∏: -", font=("Arial", 12))
        self.dice_label.pack(pady=4)

        self.head_label = tk.Label(right, text="–ì–æ–ª–æ–≤–∞: 0/0", font=("Arial", 10))
        self.head_label.pack(pady=4)

        self.roll_btn = tk.Button(right, text="–ë—Ä–æ—Å–∏—Ç—å –∫–æ—Å—Ç–∏", command=self.roll_dice, width=18)
        self.roll_btn.pack(pady=5)

        self.end_btn = tk.Button(right, text="–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥", command=self.end_turn, width=18)
        self.end_btn.pack(pady=5)

        self.new_btn = tk.Button(right, text="–ù–æ–≤–∞—è –∏–≥—Ä–∞", command=self.new_game, width=18)
        self.new_btn.pack(pady=5)

        self.dice_canvas = tk.Canvas(right, width=120, height=60, bg="#ffffff", highlightthickness=0)
        self.dice_canvas.pack(pady=8)

        self.layout = None
        self.canvas.bind("<Button-1>", self.on_click)
        self.new_game()
        self.redraw()

    def point_layout(self):
        if self.layout: return self.layout
        left, right = BOARD_MARGIN, CANVAS_W - BOARD_MARGIN
        layout = [None] * (NUM_POINTS + 1)
        total_w = right - left
        pt_w = total_w / 12.0
        
        for i in range(13, 25):
            n = i - 13
            x1 = left + n * pt_w + 6
            x2 = x1 + pt_w - 12
            layout[i] = (x1, BOARD_MARGIN, x2, BOARD_MARGIN + POINT_HEIGHT)
        for idx_pos in range(12):
            idx = 12 - idx_pos
            x1 = left + idx_pos * pt_w + 6
            x2 = x1 + pt_w - 12
            layout[idx] = (x1, CANVAS_H - BOARD_MARGIN - POINT_HEIGHT, x2, CANVAS_H - BOARD_MARGIN)
        self.layout = layout
        return layout

    def redraw(self):
        self.canvas.delete("all")
        self.canvas.create_rectangle(CANVAS_W/2 - 8, BOARD_MARGIN, CANVAS_W/2 + 8, CANVAS_H - BOARD_MARGIN,
                                     fill="#6b4323", outline="#3f2a17")
        layout = self.point_layout()
        
        for i in range(1, NUM_POINTS + 1):
            x1, y1, x2, y2 = layout[i]
            midx = (x1 + x2) / 2
            if i >= 13:
                self.canvas.create_polygon(x1, y1, x2, y1, midx, y1 + (y2 - y1) / 1.9,
                                           fill="#e8d8b0", outline="black")
            else:
                self.canvas.create_polygon(x1, y2, x2, y2, midx, y2 - (y2 - y1) / 1.9,
                                           fill="#cfa972", outline="black")
            self.canvas.create_text(midx, y2 + 10 if i < 13 else y1 - 10, text=str(i), font=("Arial", 9))
            self.draw_stack(i, layout[i])

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —à–∞—à–∫–∏
        if self.state.selected:
            r = self.point_layout()[self.state.selected]
            self.canvas.create_rectangle(r[0]-5, r[1]-5, r[2]+5, r[3]+5, outline="cyan", width=4)

        # –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤–∞–ª–∏–¥–Ω—ã—Ö —Ü–µ–ª–µ–π (–¢–û–õ–¨–ö–û –°–í–û–ò –®–ê–®–ö–ò)
        for di, targ in self.state.valid_moves:
            if targ == 0:
                head_pt = self.state.head_point(self.state.current_player)
                r = self.point_layout()[head_pt]
                self.canvas.create_rectangle(r[0], r[1], r[2], r[3], outline="gold", width=5)
            elif targ:
                r = self.point_layout()[targ]
                self.canvas.create_rectangle(r[0]+2, r[1]+2, r[2]-2, r[3]-2, outline="lime", width=4)

        self.turn_label.config(text=f"–•–æ–¥: {'–±–µ–ª—ã–µ' if self.state.current_player == WHITE else '—á—ë—Ä–Ω—ã–µ'}")
        if self.state.dice:
            self.dice_label.config(text="–ö–æ—Å—Ç–∏: " + " ".join(str(x) for x in self.state.dice))
        self.head_label.config(text=f"–ì–æ–ª–æ–≤–∞: {self.state.head[WHITE]}/{self.state.head[BLACK]}")
        self.draw_dice_canvas()

    def draw_stack(self, idx, rect):
        x1, y1, x2, y2 = rect
        cx = (x1 + x2) / 2
        whites = self.state.points[idx][WHITE]
        blacks = self.state.points[idx][BLACK]

        if whites > 0:
            self._draw_checkers(cx, rect, whites, "white", "black", idx >= 13)
        if blacks > 0:
            self._draw_checkers(cx, rect, blacks, "black", "white", idx >= 13)

    def _draw_checkers(self, cx, rect, count, color, outline, top_row):
        x1, y1, x2, y2 = rect
        step = 2 * CHECKER_RADIUS - STACK_SPACING
        if top_row:
            y = y1 + 14
            dy = step
        else:
            y = y2 - 14
            dy = -step
        for i in range(count):
            self.canvas.create_oval(cx - CHECKER_RADIUS, y - CHECKER_RADIUS,
                                    cx + CHECKER_RADIUS, y + CHECKER_RADIUS,
                                    fill=color, outline=outline, width=1)
            y += dy

    def coords_to_point(self, x, y):
        for i, r in enumerate(self.point_layout()):
            if i == 0 or not r: continue
            x1, y1, x2, y2 = r
            if x1 <= x <= x2 and min(y1, y2) <= y <= max(y1, y2):
                return i
        return None

    def on_click(self, event):
        idx = self.coords_to_point(event.x, event.y)
        if not idx:
            return
        
        if not self.state.dice:
            self.info_label.config(text="–°–Ω–∞—á–∞–ª–∞ –±—Ä–æ—Å—å—Ç–µ –∫–æ—Å—Ç–∏!")
            return

        player = self.state.current_player
        
        # 1. –ï—Å–ª–∏ –ù–ï –í–´–ë–†–ê–ù–ê —à–∞—à–∫–∞ - –≤—ã–±–∏—Ä–∞–µ–º –°–í–û–Æ
        if not self.state.selected:
            if self.state.can_move_from(idx):
                self.state.selected = idx
                self.state.valid_moves = self.state.possible_targets_from(idx)
                if not self.state.valid_moves:
                    self.info_label.config(text=f"–ù–µ—Ç —Ö–æ–¥–æ–≤ —Å {idx} (–≥–æ–ª–æ–≤–∞ —É–∂–µ —Å–Ω—è—Ç–∞ 1 —Ä–∞–∑?)")
                    self.state.selected = None
                else:
                    self.info_label.config(text=f"‚úì –í—ã–±—Ä–∞–Ω–æ {idx} ‚Üí –∫–ª–∏–∫–Ω–∏—Ç–µ –°–í–û–ò —à–∞—à–∫–∏ (–∑–µ–ª–µ–Ω–∞—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞)")
                self.redraw()
            else:
                self.info_label.config(text=f"–¢—É—Ç –Ω–µ—Ç –≤–∞—à–∏—Ö —à–∞—à–µ–∫!")
            return

        # 2. –ï—Å–ª–∏ –í–´–ë–†–ê–ù–ê - –∏—â–µ–º –¶–ï–õ–¨ —Å—Ä–µ–¥–∏ –°–í–û–ò–• —à–∞—à–µ–∫
        chosen = None
        for di, targ in self.state.valid_moves:
            if targ == idx or (targ == 0 and idx == self.state.head_point(player)):
                chosen = (di, targ if targ else 0)
                break
        
        if chosen:
            ok = self.state.apply_move(self.state.selected, chosen[1], chosen[0])
            if ok:
                winner = self.state.check_win()
                if winner:
                    messagebox.showinfo("üéâ –ü–û–ë–ï–î–ê!", f"{winner.title()} –≤–µ—Ä–Ω—É–ª–∏ –≤—Å–µ –≤ –≥–æ–ª–æ–≤—É!")
                    self.new_game()
                    return
                if self.state.all_dice_used():
                    self.end_turn()
                else:
                    self.info_label.config(text="‚úÖ –•–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω! –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ")
            else:
                self.info_label.config(text="‚ùå –•–æ–¥ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω!")
        else:
            self.info_label.config(text="‚ùå –ö–ª–∏–∫–Ω–∏—Ç–µ –ó–ï–õ–ï–ù–£–Æ –ø–æ–¥—Å–≤–µ—Ç–∫—É (—Ç–æ–ª—å–∫–æ –°–í–û–ò —à–∞—à–∫–∏)!")

        self.state.selected = None
        self.state.valid_moves = []
        self.redraw()

    def roll_dice(self):
        if self.state.dice and not self.state.all_dice_used():
            self.info_label.config(text="–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –í–°–ï –∫–æ—Å—Ç–∏ —Å–Ω–∞—á–∞–ª–∞!")
            return
        self.state.roll_dice()
        self.info_label.config(text="üîÑ –ë—Ä–æ—à–µ–Ω—ã –∫–æ—Å—Ç–∏. 1-–π –∫–ª–∏–∫=–í–ê–®–ê —à–∞—à–∫–∞, 2-–π=–°–í–û–ò —à–∞—à–∫–∏")
        self.redraw()

    def end_turn(self):
        self.state.current_player = BLACK if self.state.current_player == WHITE else WHITE
        self.state.dice = ()
        self.state.dice_used = []
        self.state.selected = None
        self.state.valid_moves = []
        self.state.head_moved_this_turn = False
        self.info_label.config(text="üëã –•–æ–¥ –ø–µ—Ä–µ–¥–∞–Ω")
        self.redraw()

    def new_game(self):
        self.state = GameState()
        self.info_label.config(text="üéÆ –î–ª–∏–Ω–Ω—ã–µ –Ω–∞—Ä–¥—ã (—Ç–æ–ª—å–∫–æ –Ω–∞ —Å–≤–æ–∏ —à–∞—à–∫–∏)! –ë—Ä–æ—Å—å—Ç–µ –∫–æ—Å—Ç–∏.")
        self.redraw()

    def draw_dice_canvas(self):
        self.dice_canvas.delete("all")
        if not self.state.dice: return
        for i, v in enumerate(self.state.dice):
            x, y = 20 + i * 28, 30
            self.dice_canvas.create_rectangle(x-12, y-12, x+12, y+12, fill="#ffffff", outline="black", width=2)
            for dx, dy in self.get_dice_dots(v):
                self.dice_canvas.create_oval(x+dx-2, y+dy-2, x+dx+2, y+dy+2, fill="black")
        if any(self.state.dice_used):
            self.dice_canvas.create_text(60, 50, text="‚úì –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã", font=("Arial", 8), fill="green")

    def get_dice_dots(self, value):
        return {
            1: [(0,0)],
            2: [(-6,-6),(6,6)],
            3: [(-6,-6),(0,0),(6,6)],
            4: [(-6,-6),(6,-6),(-6,6),(6,6)],
            5: [(-6,-6),(6,-6),(0,0),(-6,6),(6,6)],
            6: [(-6,-6),(6,-6),(-6,0),(6,0),(-6,6),(6,6)]
        }.get(value, [])

# --- –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è ---
def app_auth_user(login, password, register=False):
    try:
        if register:
            if os.path.exists(USERS_FILE):
                with open(USERS_FILE, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split(":")
                        if len(parts) >= 1 and decrypt(parts[0]) == login:
                            return False, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
            with open(USERS_FILE, "a", encoding="utf-8") as f:
                f.write(f"{encrypt(login)}:{encrypt(password)}\n")
            return True, "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞"
        else:
            if not os.path.exists(USERS_FILE):
                return False, "–ù–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"
            with open(USERS_FILE, "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts) == 2 and decrypt(parts[0]) == login and decrypt(parts[1]) == password:
                        return True, "–í—Ö–æ–¥ —É—Å–ø–µ—à–µ–Ω"
            return False, "–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω/–ø–∞—Ä–æ–ª—å"
    except Exception:
        return False, "–û—à–∏–±–∫–∞ —Ñ–∞–π–ª–∞"

def open_auth_window():
    auth = tk.Tk()
    auth.title("–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è ‚Äî –î–ª–∏–Ω–Ω—ã–µ —Ä—É—Å—Å–∫–∏–µ –Ω–∞—Ä–¥—ã")
    auth.geometry("360x220")
    auth.resizable(False, False)

    tk.Label(auth, text="–õ–æ–≥–∏–Ω:").pack(pady=(12,0))
    login_var = tk.StringVar()
    login_entry = tk.Entry(auth, textvariable=login_var, width=30)
    login_entry.pack(pady=4)

    tk.Label(auth, text="–ü–∞—Ä–æ–ª—å:").pack(pady=(8,0))
    pass_var = tk.StringVar()
    pass_entry = tk.Entry(auth, textvariable=pass_var, show="*", width=30)
    pass_entry.pack(pady=4)

    status = tk.Label(auth, text="", fg="red")
    status.pack(pady=6)

    def do_login():
        u = login_var.get().strip()
        p = pass_var.get().strip()
        ok, msg = app_auth_user(u, p, register=False)
        status.config(text=msg, fg="green" if ok else "red")
        if ok:
            auth.destroy()
            open_game_window(u)

    def do_register():
        u = login_var.get().strip()
        p = pass_var.get().strip()
        if not u or not p:
            status.config(text="–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–ª—è!", fg="red")
            return
        ok, msg = app_auth_user(u, p, register=True)
        status.config(text=msg, fg="green" if ok else "red")

    btn_frame = tk.Frame(auth)
    btn_frame.pack(pady=6)
    tk.Button(btn_frame, text="–í–æ–π—Ç–∏", width=12, command=do_login).pack(side=tk.LEFT, padx=6)
    tk.Button(btn_frame, text="–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è", width=12, command=do_register).pack(side=tk.LEFT, padx=6)

    auth.mainloop()

def open_game_window(user):
    root = tk.Tk()
    app = NardyApp(root, user)
    root.minsize(980, 560)
    root.mainloop()

if __name__ == "__main__":
    open_auth_window()
