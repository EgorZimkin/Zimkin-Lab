# kursovaya1.py -- ИСПРАВЛЕННАЯ версия ДЛИННЫХ НАРД (без выноса, по кругу)
import tkinter as tk
from tkinter import messagebox
import random
import os

# --- Константы ---
WHITE = "white"
BLACK = "black"
CHECKERS_PER_PLAYER = 15
USERS_FILE = "users.txt"
ENC_SHIFT = 10

CANVAS_W, CANVAS_H = 960, 520
BOARD_MARGIN = 30
POINT_HEIGHT = 220
NUM_POINTS = 24

CHECKER_RADIUS = 14
STACK_SPACING = 4

# --- Шифрование ---
def encrypt(text, shift=ENC_SHIFT):
    return "".join(chr(ord(c) + shift) for c in text)

def decrypt(text, shift=ENC_SHIFT):
    return "".join(chr(ord(c) - shift) for c in text)

# --- Игровое состояние ДЛИННЫХ НАРД ---
class GameState:
    def __init__(self):
        # точки 1..24, ДЛИННЫЕ НАРДЫ: белые стартуют на 1, черные на 24
        self.points = [{"white": 0, "black": 0} for _ in range(NUM_POINTS + 1)]
        self.points[1]["white"] = CHECKERS_PER_PLAYER    # белые стартуют на 1
        self.points[24]["black"] = CHECKERS_PER_PLAYER   # черные стартуют на 24
        
        self.current_player = WHITE
        self.dice = ()
        self.dice_used = []
        self.selected = None
        self.valid_moves = []

    def direction_for(self, player):
        # ДЛИННЫЕ НАРДЫ: ОБОИ ИДУТ ПО ЧАСОВОЙ СТРЕЛКЕ (индекс растет: 1->2->...->24->1)
        return 1

    def roll_dice(self):
        a = random.randint(1, 6)
        b = random.randint(1, 6)
        if a == b:
            self.dice = (a, a, a, a)
            self.dice_used = [False, False, False, False]
        else:
            self.dice = (a, b)
            self.dice_used = [False, False]
        self.selected = None
        self.valid_moves = []

    def all_dice_used(self):
        return len(self.dice_used) > 0 and all(self.dice_used)

    def can_move_from(self, idx):
        return 1 <= idx <= NUM_POINTS and self.points[idx][self.current_player] > 0

    def is_blocked(self, target_idx):
        # Нельзя на точку с шашками противника (даже одной)
        if not (1 <= target_idx <= NUM_POINTS):
            return True
        opp = BLACK if self.current_player == WHITE else WHITE
        return self.points[target_idx][opp] > 0

    def possible_targets_from(self, start):
        res = []
        if not self.can_move_from(start):
            return res
        
        direction = self.direction_for(self.current_player)
        for di, val in enumerate(self.dice):
            if di >= len(self.dice_used) or self.dice_used[di]:
                continue
            target = ((start - 1 + direction * val) % NUM_POINTS) + 1  # КРУГОВОЕ движение
            if not self.is_blocked(target):
                res.append((di, target))
        return res

    def apply_move(self, start, target, di):
        player = self.current_player
        if not (0 <= di < len(self.dice_used)):
            return False
            
        if target == 0 or not (1 <= target <= NUM_POINTS):
            return False
        if self.points[start][player] <= 0:
            return False
        if self.is_blocked(target):
            return False
        
        # Простой ход: переносим шашку
        self.points[start][player] -= 1
        self.points[target][player] += 1
        self.dice_used[di] = True
        self.selected = None
        self.valid_moves = []
        return True

    def check_win(self):
        # Победа: все свои шашки собраны на одной точке (условно)
        white_home = sum(self.points[24][WHITE] for _ in [1]) == CHECKERS_PER_PLAYER
        black_home = sum(self.points[1][BLACK] for _ in [1]) == CHECKERS_PER_PLAYER
        if white_home:
            return WHITE
        if black_home:
            return BLACK
        return None

# --- Главное игровое окно ---
class NardyApp:
    def __init__(self, root, user):
        self.root = root
        self.user = user
        root.title(f"Длинные нарды — {user}")
        self.state = GameState()

        # canvas
        self.canvas = tk.Canvas(root, width=CANVAS_W, height=CANVAS_H, bg="#f5deb3")
        self.canvas.pack(side=tk.LEFT, padx=8, pady=8)

        # правая панель (УБРАЛИ кнопку выноса)
        right = tk.Frame(root)
        right.pack(side=tk.RIGHT, fill=tk.Y, padx=8, pady=8)

        self.info_label = tk.Label(right, text=f"Пользователь: {user}", wraplength=200, justify="left")
        self.info_label.pack(pady=6)

        self.turn_label = tk.Label(right, text="Ход: белые", font=("Arial", 12, "bold"))
        self.turn_label.pack(pady=4)

        self.dice_label = tk.Label(right, text="Кости: -", font=("Arial", 12))
        self.dice_label.pack(pady=4)

        self.roll_btn = tk.Button(right, text="Бросить кости", command=self.roll_dice, width=18)
        self.roll_btn.pack(pady=5)

        self.end_btn = tk.Button(right, text="Завершить ход", command=self.end_turn, width=18)
        self.end_btn.pack(pady=5)

        self.new_btn = tk.Button(right, text="Новая игра", command=self.new_game, width=18)
        self.new_btn.pack(pady=5)

        self.dice_canvas = tk.Canvas(right, width=120, height=60, bg="#ffffff", highlightthickness=0)
        self.dice_canvas.pack(pady=8)

        # бинды
        self.canvas.bind("<Button-1>", self.on_click)

        # старт
        self.new_game()
        self.redraw()

    # --- раскладка точек (1..24) КРУГОМ ---
    def point_layout(self):
        layout = [None] * (NUM_POINTS + 1)
        total_w = CANVAS_W - 2 * BOARD_MARGIN
        pt_w = total_w / NUM_POINTS
        
        # Все 24 точки в один ряд снизу вверх (упрощенно для длинных нард)
        for i in range(1, NUM_POINTS + 1):
            x1 = BOARD_MARGIN + (i-1) * pt_w + 6
            x2 = x1 + pt_w - 12
            layout[i] = (x1, CANVAS_H - BOARD_MARGIN - POINT_HEIGHT, x2, CANVAS_H - BOARD_MARGIN)
        return layout

    # --- перерисовка ---
    def redraw(self):
        self.canvas.delete("all")
        layout = self.point_layout()
        
        for i in range(1, NUM_POINTS + 1):
            x1, y1, x2, y2 = layout[i]
            midx = (x1 + x2) / 2
            # треугольники для точек
            self.canvas.create_polygon(x1, y2, x2, y2, midx, y2 - POINT_HEIGHT/2,
                                       fill="#cfa972", outline="black", width=2)
            self.canvas.create_text(midx, y2 + 15, text=str(i), font=("Arial", 9))
            self.draw_stack(i, layout[i])

        # подсветка выбранной точки
        if self.state.selected:
            r = layout[self.state.selected]
            self.canvas.create_rectangle(r[0], r[1], r[2], r[3], outline="cyan", width=4)

        # подсветка возможных целей
        for di, targ in self.state.valid_moves:
            r = layout[targ]
            self.canvas.create_rectangle(r[0]+5, r[1]+5, r[2]-5, r[3]-5, outline="lime", width=3)

        self.turn_label.config(text=f"Ход: {'белые' if self.state.current_player == WHITE else 'чёрные'}")
        if self.state.dice:
            self.dice_label.config(text="Кости: " + " ".join(str(x) for x in self.state.dice))
        self.draw_dice_canvas()

    # --- отрисовка стопки ---
    def draw_stack(self, idx, rect):
        x1, y1, x2, y2 = rect
        cx = (x1 + x2) / 2
        whites = self.state.points[idx]["white"]
        blacks = self.state.points[idx]["black"]

        # белые снизу вверх
        y = y2 - 14
        for i in range(whites):
            self.canvas.create_oval(cx - CHECKER_RADIUS, y - CHECKER_RADIUS,
                                    cx + CHECKER_RADIUS, y + CHECKER_RADIUS,
                                    fill="white", outline="black")
            y -= STACK_SPACING + 2

        # черные сверху вниз (напротив белых)
        y = y1 + 14
        for i in range(blacks):
            self.canvas.create_oval(cx - CHECKER_RADIUS, y - CHECKER_RADIUS,
                                    cx + CHECKER_RADIUS, y + CHECKER_RADIUS,
                                    fill="black", outline="white")
            y += STACK_SPACING + 2

    # --- взаимодействие ---
    def coords_to_point(self, x, y):
        for i, r in enumerate(self.point_layout()):
            if i == 0: continue
            if not r: continue
            x1, y1, x2, y2 = r
            if x1 <= x <= x2 and y1 <= y <= y2:
                return i
        return None

    def on_click(self, event):
        idx = self.coords_to_point(event.x, event.y)
        if not idx:
            return
        if not self.state.dice:
            self.info_label.config(text="Сначала бросьте кости!")
            return
        
        # выбор своей шашки
        if self.state.can_move_from(idx):
            self.state.selected = idx
            self.state.valid_moves = self.state.possible_targets_from(idx)
            if not self.state.valid_moves:
                self.info_label.config(text=f"Нет ходов с точки {idx}")
            else:
                self.info_label.config(text=f"Выбрано: {idx}. Кликните цель.")
            self.redraw()
            return
        
        # выбор цели
        if self.state.selected:
            chosen = None
            for di, targ in self.state.valid_moves:
                if targ == idx:
                    chosen = (di, targ)
                    break
            if chosen:
                if self.state.apply_move(self.state.selected, chosen[1], chosen[0]):
                    winner = self.state.check_win()
                    if winner:
                        messagebox.showinfo("Победа!", f"Победили {winner}!")
                        self.new_game()
                        return
                    if self.state.all_dice_used():
                        self.end_turn()
                    else:
                        self.info_label.config(text="Ход OK. Ещё кости.")
                self.state.selected = None
                self.state.valid_moves = []
                self.redraw()
                return

    def roll_dice(self):
        if self.state.dice and not self.state.all_dice_used():
            self.info_label.config(text="Доиграйте ход!")
            return
        self.state.roll_dice()
        self.info_label.config(text="Выберите шашку -> цель")
        self.redraw()

    def end_turn(self):
        self.state.current_player = BLACK if self.state.current_player == WHITE else WHITE
        self.state.dice = ()
        self.state.dice_used = []
        self.state.selected = None
        self.state.valid_moves = []
        self.info_label.config(text="Ход передан оппоненту")
        self.redraw()

    def new_game(self):
        self.state = GameState()
        self.info_label.config(text="Новая партия начата!")
        self.redraw()

    def draw_dice_canvas(self):
        self.dice_canvas.delete("all")
        if not self.state.dice:
            return
        for i, v in enumerate(self.state.dice):
            x = 20 + i * 28
            y = 30
            self.dice_canvas.create_rectangle(x-12, y-12, x+12, y+12, fill="white", outline="black")
            for dx, dy in self.get_dice_dots(v):
                self.dice_canvas.create_oval(x+dx-2, y+dy-2, x+dx+2, y+dy+2, fill="black")

    def get_dice_dots(self, value):
        dots = {1: [(0,0)], 2:[(-6,-6),(6,6)], 3:[(-6,-6),(0,0),(6,6)], 
                4:[(-6,-6),(6,-6),(-6,6),(6,6)], 5:[(-6,-6),(6,-6),(0,0),(-6,6),(6,6)], 
                6:[(-6,-6),(6,-6),(-6,0),(6,0),(-6,6),(6,6)]}
        return dots.get(value, [])

# --- Авторизация (твоя рабочая) ---
def app_auth_user(login, password, register=False):
    try:
        if register:
            if os.path.exists(USERS_FILE):
                with open(USERS_FILE, "r", encoding="utf-8") as f:
                    for line in f:
                        parts = line.strip().split(":")
                        if len(parts) >= 1 and decrypt(parts[0]) == login:
                            return False, "Пользователь уже существует"
            with open(USERS_FILE, "a", encoding="utf-8") as f:
                f.write(f"{encrypt(login)}:{encrypt(password)}\n")
            return True, "Регистрация успешна"
        else:
            if not os.path.exists(USERS_FILE):
                return False, "Нет пользователей"
            with open(USERS_FILE, "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts) == 2 and decrypt(parts[0]) == login and decrypt(parts[1]) == password:
                        return True, "Вход успешен"
            return False, "Неверный логин/пароль"
    except Exception:
        return False, "Ошибка файла"

def open_auth_window():
    auth = tk.Tk()
    auth.title("Авторизация — Длинные нарды")
    auth.geometry("360x220")
    auth.resizable(False, False)

    tk.Label(auth, text="Логин:").pack(pady=(12,0))
    login_var = tk.StringVar()
    login_entry = tk.Entry(auth, textvariable=login_var, width=30)
    login_entry.pack(pady=4)

    tk.Label(auth, text="Пароль:").pack(pady=(8,0))
    pass_var = tk.StringVar()
    pass_entry = tk.Entry(auth, textvariable=pass_var, show="*", width=30)
    pass_entry.pack(pady=4)

    status = tk.Label(auth, text="", fg="red")
    status.pack(pady=6)

    def do_login():
        u = login_var.get().strip()
        p = pass_var.get().strip()
        ok, msg = app_auth_user(u, p, register=False)
        status.config(text=msg, fg="green" if ok else "red")
        if ok:
            auth.destroy()
            open_game_window(u)

    def do_register():
        u = login_var.get().strip()
        p = pass_var.get().strip()
        if not u or not p:
            status.config(text="Заполните поля!", fg="red")
            return
        ok, msg = app_auth_user(u, p, register=True)
        status.config(text=msg, fg="green" if ok else "red")

    btn_frame = tk.Frame(auth)
    btn_frame.pack(pady=6)
    tk.Button(btn_frame, text="Войти", width=12, command=do_login).pack(side=tk.LEFT, padx=6)
    tk.Button(btn_frame, text="Регистрация", width=12, command=do_register).pack(side=tk.LEFT, padx=6)

    auth.mainloop()

def open_game_window(user):
    root = tk.Tk()
    app = NardyApp(root, user)
    root.minsize(980, 560)
    root.mainloop()

if __name__ == "__main__":
    open_auth_window()
