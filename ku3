import tkinter as tk
from tkinter import messagebox
import random
import os
from typing import Optional, List

class RussianBackgammon:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("–†—É—Å—Å–∫–∏–µ –ù–∞—Ä–¥—ã - –ö—É—Ä—Å–æ–≤–∞—è —Ä–∞–±–æ—Ç–∞")
        self.root.geometry("1000x800+150+50")
        
        # –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        self.current_user: Optional[str] = None
        self.board: List[int] = [0]*24
        self.current_player: int = 1  # 1 - –±–µ–ª—ã–µ, -1 - —á–µ—Ä–Ω—ã–µ
        self.dice: List[int] = []
        self.used_dice: List[int] = []
        self.selected_checker: Optional[int] = None
        self.game_started: bool = False
        
        # –¶–≤–µ—Ç–∞
        self.colors = {
            "board": "#DEB887",
            "light": "#F5F5DC",
            "dark": "#8B4513",
            "white": "#FFFFFF",
            "black": "#000000",
            "highlight": "#FF0000",
            "info_bg": "#F0F0F0"
        }
        
        # GUI
        self.create_gui()
        self.create_auth_form()

    def create_gui(self):
        # –ö–∞–Ω–≤–∞—Å –¥–ª—è –¥–æ—Å–∫–∏
        self.canvas = tk.Canvas(self.root, width=900, height=550,
                                bg=self.colors["board"], highlightthickness=2,
                                highlightbackground=self.colors["dark"])
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è –ø–∞–Ω–µ–ª—å
        self.info_frame = tk.Frame(self.root, bg=self.colors["info_bg"], height=60)
        self.current_player_label = tk.Label(self.info_frame, text="–í–æ–π–¥–∏—Ç–µ –≤ –∏–≥—Ä—É",
                                             font=("Arial", 16, "bold"), bg=self.colors["info_bg"])
        self.status_label = tk.Label(self.info_frame, text="",
                                     font=("Arial", 12), bg=self.colors["info_bg"])
        # –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        self.control_frame = tk.Frame(self.root, bg=self.colors["info_bg"])
        self.dice_label = tk.Label(self.control_frame, text="–ö–æ—Å—Ç–∏: ",
                                   font=("Arial", 14, "bold"), bg=self.colors["info_bg"])
        
    def create_auth_form(self):
        self.auth_frame = tk.Frame(self.root, bg=self.colors["light"])
        self.auth_frame.pack(fill=tk.BOTH, expand=True)
        
        title_frame = tk.Frame(self.auth_frame, bg=self.colors["dark"])
        title_frame.pack(fill=tk.X, pady=20)
        tk.Label(title_frame, text="–†–£–°–°–ö–ò–ï –î–õ–ò–ù–ù–´–ï –ù–ê–†–î–´", font=("Arial", 24, "bold"),
                 fg="white", bg=self.colors["dark"], pady=15).pack()
        
        content_frame = tk.Frame(self.auth_frame, bg=self.colors["light"])
        content_frame.pack(expand=True, pady=50)
        login_frame = tk.Frame(content_frame, bg=self.colors["light"])
        login_frame.pack(pady=30)
        tk.Label(login_frame, text="–õ–æ–≥–∏–Ω:", font=("Arial", 14), bg=self.colors["light"]).grid(row=0, column=0, padx=10, pady=10)
        self.login_entry = tk.Entry(login_frame, font=("Arial", 14), width=20)
        self.login_entry.grid(row=0, column=1, padx=10, pady=10)
        tk.Label(login_frame, text="–ü–∞—Ä–æ–ª—å:", font=("Arial", 14), bg=self.colors["light"]).grid(row=1, column=0, padx=10, pady=10)
        self.password_entry = tk.Entry(login_frame, show="*", font=("Arial", 14), width=20)
        self.password_entry.grid(row=1, column=1, padx=10, pady=10)
        
        btn_frame = tk.Frame(content_frame, bg=self.colors["light"])
        btn_frame.pack(pady=30)
        tk.Button(btn_frame, text="–í–æ–π—Ç–∏", command=self.login, font=("Arial", 14, "bold"),
                  bg="#4CAF50", fg="white", width=12, height=1).pack(side=tk.LEFT, padx=15)
        tk.Button(btn_frame, text="–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è", command=self.register, font=("Arial", 14, "bold"),
                  bg="#2196F3", fg="white", width=18, height=1).pack(side=tk.LEFT, padx=15)
        
        self.auth_status_label = tk.Label(content_frame, text="", font=("Arial", 12), fg="red", bg=self.colors["light"])
        self.auth_status_label.pack(pady=10)
        self.root.bind('<Return>', lambda e: self.login())
    
    def encrypt(self, text: str, shift: int = 3) -> str:
        return ''.join(chr(ord(c)+shift) for c in text)
    def decrypt(self, text: str, shift: int = 3) -> str:
        return ''.join(chr(ord(c)-shift) for c in text)
    
    def register(self):
        login = self.login_entry.get().strip()
        password = self.password_entry.get().strip()
        if not login or not password:
            self.auth_status_label.config(text="–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è!")
            return
        if os.path.exists("users.txt"):
            with open("users.txt", "r", encoding="utf-8") as f:
                for line in f:
                    parts = line.strip().split(":")
                    if len(parts)==2 and self.decrypt(parts[0])==login:
                        self.auth_status_label.config(text="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")
                        return
        with open("users.txt","a",encoding="utf-8") as f:
            f.write(f"{self.encrypt(login)}:{self.encrypt(password)}\n")
        self.auth_status_label.config(text="–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!", fg="green")
    
    def login(self):
        login = self.login_entry.get().strip()
        password = self.password_entry.get().strip()
        if not login or not password:
            self.auth_status_label.config(text="–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è!")
            return
        if not os.path.exists("users.txt"):
            self.auth_status_label.config(text="–§–∞–π–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω!")
            return
        with open("users.txt","r",encoding="utf-8") as f:
            for line in f:
                parts = line.strip().split(":")
                if len(parts)==2 and self.decrypt(parts[0])==login and self.decrypt(parts[1])==password:
                    self.current_user = login
                    self.start_game()
                    return
        self.auth_status_label.config(text="–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å!")
    
    def start_game(self):
        self.game_started = True
        self.setup_board()
        self.show_game_interface()
        self.roll_dice()
    
    def setup_board(self):
        self.board = [0]*24
        self.board[0] = -15  # –ë–µ–ª—ã–µ
        self.board[12] = 15  # –ß–µ—Ä–Ω—ã–µ
    
    def show_game_interface(self):
        self.auth_frame.pack_forget()
        self.info_frame.pack(fill=tk.X, padx=10, pady=5)
        self.current_player_label.pack(side=tk.LEFT, padx=20, pady=10)
        self.status_label.pack(side=tk.LEFT, padx=20, pady=10)
        self.canvas.pack(padx=20,pady=10, fill=tk.BOTH, expand=True)
        self.canvas.bind("<Button-1>", self.on_canvas_click)
        self.control_frame.pack(fill=tk.X, padx=20, pady=10)
        self.dice_label.pack(side=tk.LEFT, padx=20, pady=10)
        tk.Button(self.control_frame, text="–ë—Ä–æ—Å–∏—Ç—å –∫–æ—Å—Ç–∏", command=self.roll_dice,
                  font=("Arial", 12, "bold"), bg="#FF9800", fg="white", width=12, height=1).pack(side=tk.LEFT, padx=10)
        tk.Button(self.control_frame, text="–ù–æ–≤–∞—è –∏–≥—Ä–∞", command=self.new_game,
                  font=("Arial", 12, "bold"), bg="#009688", fg="white", width=12, height=1).pack(side=tk.LEFT, padx=10)
        self.update_status()
        self.draw_board()
    
    def draw_board(self):
        self.canvas.delete("all")
        # –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–æ–Ω –¥–æ—Å–∫–∏
        self.canvas.create_rectangle(50,50,850,500,fill=self.colors["board"],outline=self.colors["dark"],width=4)
        for i in range(12):
            x1 = 100+i*60
            x2 = x1+30
            x3 = x1+60
            color = self.colors["light"] if i%2==0 else self.colors["dark"]
            self.canvas.create_polygon([x1,50,x2,250,x3,50], fill=color, outline=self.colors["dark"], width=2)
            self.canvas.create_polygon([x1,500,x2,300,x3,500], fill=color, outline=self.colors["dark"], width=2)
        self.canvas.create_rectangle(50,250,850,300, fill=self.colors["dark"], outline=self.colors["dark"])
        self.draw_checkers()
    
    def draw_checkers(self):
        for i in range(24):
            count = abs(self.board[i])
            if count==0:
                continue
            player = -1 if self.board[i]<0 else 1
            if i<12:
                x=130+i*60
                base_y=70
                direction=1
            else:
                x=130+(23-i)*60
                base_y=480
                direction=-1
            for j in range(min(count,8)):
                y=base_y+j*25*direction
                color=self.colors["white"] if player==1 else self.colors["black"]
                outline=self.colors["black"] if player==1 else self.colors["white"]
                self.canvas.create_oval(x-20,y-20,x+20,y+20, fill=color, outline=outline, width=2)
            if count>8:
                self.canvas.create_text(x, base_y+8*25*direction, text=str(count), font=("Arial",10,"bold"), fill="red" if player==1 else "yellow")
    
    def roll_dice(self):
        if not self.game_started:
            return
        self.dice=[random.randint(1,6), random.randint(1,6)]
        self.used_dice=[]
        if self.dice[0]==self.dice[1]:
            self.dice=self.dice*2
        self.update_status()
        self.draw_board()
    
    def on_canvas_click(self,event):
        pos=self.get_position_from_click(event.x,event.y)
        if pos is not None:
            self.handle_checker_click(pos)
    
    def get_position_from_click(self,x:int,y:int)->Optional[int]:
        if 50<=y<=250:
            for i in range(12):
                if 100+i*60<=x<=160+i*60:
                    return i
        elif 300<=y<=500:
            for i in range(12):
                if 100+i*60<=x<=160+i*60:
                    return 23-i
        return None
    
    def handle_checker_click(self,pos:int):
        if self.selected_checker is None:
            if self.board[pos]*self.current_player>0:
                self.selected_checker=pos
                self.highlight_position(pos)
                self.status_label.config(text="–í—ã–±–µ—Ä–∏—Ç–µ –∫—É–¥–∞ —Ö–æ–¥–∏—Ç—å")
        else:
            if self.is_valid_move(self.selected_checker,pos):
                self.make_move(self.selected_checker,pos)
                self.selected_checker=None
                self.check_game_end()
            else:
                self.selected_checker=None
                self.status_label.config(text="–ù–µ–≤–µ—Ä–Ω—ã–π —Ö–æ–¥!")
            self.draw_board()
    
    def highlight_position(self,pos:int):
        self.draw_board()
        if pos<12:
            x=130+pos*60
            y=70
        else:
            x=130+(23-pos)*60
            y=480
        self.canvas.create_oval(x-25,y-25,x+25,y+25, outline=self.colors["highlight"], width=3)
    
    def is_valid_move(self,from_pos:int,to_pos:int)->bool:
        if not self.dice:
            return False
        if self.board[from_pos]*self.current_player<=0:
            return False
        if self.current_player==1:
            distance=(to_pos-from_pos)%24
            if distance<=0: distance+=24
        else:
            distance=(from_pos-to_pos)%24
            if distance<=0: distance+=24
        if distance not in self.dice and distance not in self.used_dice:
            return False
        if self.board[to_pos]*self.current_player<-1:
            return False
        return True
    
    def make_move(self,from_pos:int,to_pos:int):
        if self.current_player==1:
            distance=(to_pos-from_pos)%24
            if distance<=0: distance+=24
        else:
            distance=(from_pos-to_pos)%24
            if distance<=0: distance+=24
        if distance in self.dice: self.dice.remove(distance); self.used_dice.append(distance)
        else: self.used_dice.remove(distance)
        self.board[from_pos]-=self.current_player
        if self.board[to_pos]*self.current_player==-1:
            if self.current_player==1: self.board[12]+=1
            else: self.board[0]-=1
        else:
            self.board[to_pos]+=self.current_player
        if not self.dice:
            self.current_player*=-1
            self.roll_dice()
        self.update_status()
    
    def update_status(self):
        player_text="–ë–ï–õ–´–ï" if self.current_player==1 else "–ß–ï–†–ù–´–ï"
        user_text=f"–ò–≥—Ä–æ–∫: {self.current_user}" if self.current_player==1 else "–ò–≥—Ä–æ–∫ 2"
        self.current_player_label.config(text=f"{user_text} | –•–û–î: {player_text}")
        dice_text=f"üé≤ –ö–æ—Å—Ç–∏: {self.dice}"
        if self.used_dice:
            dice_text+=f" | –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {self.used_dice}"
        self.dice_label.config(text=dice_text)
        if not self.dice:
            self.status_label.config(text="–ë—Ä–æ—Å—å—Ç–µ –∫–æ—Å—Ç–∏!")
        elif self.selected_checker is None:
            self.status_label.config(text="–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É –¥–ª—è —Ö–æ–¥–∞")
    
    def check_game_end(self):
        white_win=all(self.board[i]>=0 for i in range(24))
        black_win=all(self.board[i]<=0 for i in range(24))
        if white_win: messagebox.showinfo("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞","–ë–µ–ª—ã–µ –≤—ã–∏–≥—Ä–∞–ª–∏!"); self.new_game()
        elif black_win: messagebox.showinfo("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞","–ß–µ—Ä–Ω—ã–µ –≤—ã–∏–≥—Ä–∞–ª–∏!"); self.new_game()
    
    def new_game(self):
        self.setup_board()
        self.current_player=1
        self.selected_checker=None
        self.dice=[]
        self.used_dice=[]
        self.roll_dice()
        self.draw_board()
    
    def run(self):
        self.root.mainloop()

if __name__=="__main__":
    game=RussianBackgammon()
    game.run()
